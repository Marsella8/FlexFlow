// THIS FILE WAS AUTO-GENERATED BY proj. DO NOT MODIFY IT!
// If you would like to modify this datatype, instead modify
// lib/op-attrs/include/op-attrs/pcg_operator_attrs.variant.toml
/* proj-data
{
  "generated_from": "e1b5c307ae023ce6d504f605c7ef8491"
}
*/

#include "op-attrs/pcg_operator_attrs.dtg.h"

#include "fmt/format.h"
#include <sstream>
#include <stdexcept>

namespace FlexFlow {
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::BatchMatmulAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::BatchNormAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::CastAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ConcatAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::Conv2DAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::DropoutAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ElementBinaryAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ElementUnaryAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ElementScalarUnaryAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::EmbeddingAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::FlatAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::GatherAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::InputAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::LayerNormAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::LinearAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::MultiHeadAttentionAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::NoopAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::Pool2DAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ReduceAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ReverseAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::ReshapeAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::SplitAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::SoftmaxAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::TopKAttrs const &v)
    : raw_variant(v) {}
PCGOperatorAttrs::PCGOperatorAttrs(::FlexFlow::TransposeAttrs const &v)
    : raw_variant(v) {}
bool PCGOperatorAttrs::operator==(PCGOperatorAttrs const &other) const {
  return this->raw_variant == other.raw_variant;
}
bool PCGOperatorAttrs::operator!=(PCGOperatorAttrs const &other) const {
  return this->raw_variant != other.raw_variant;
}
bool PCGOperatorAttrs::operator<(PCGOperatorAttrs const &other) const {
  return this->raw_variant < other.raw_variant;
}
bool PCGOperatorAttrs::operator>(PCGOperatorAttrs const &other) const {
  return this->raw_variant > other.raw_variant;
}
bool PCGOperatorAttrs::operator<=(PCGOperatorAttrs const &other) const {
  return this->raw_variant <= other.raw_variant;
}
bool PCGOperatorAttrs::operator>=(PCGOperatorAttrs const &other) const {
  return this->raw_variant >= other.raw_variant;
}
} // namespace FlexFlow
namespace std {
size_t hash<::FlexFlow::PCGOperatorAttrs>::operator()(
    ::FlexFlow::PCGOperatorAttrs const &x) const {
  return std::hash<std::variant<::FlexFlow::BatchMatmulAttrs,
                                ::FlexFlow::BatchNormAttrs,
                                ::FlexFlow::CastAttrs,
                                ::FlexFlow::ConcatAttrs,
                                ::FlexFlow::Conv2DAttrs,
                                ::FlexFlow::DropoutAttrs,
                                ::FlexFlow::ElementBinaryAttrs,
                                ::FlexFlow::ElementUnaryAttrs,
                                ::FlexFlow::ElementScalarUnaryAttrs,
                                ::FlexFlow::EmbeddingAttrs,
                                ::FlexFlow::FlatAttrs,
                                ::FlexFlow::GatherAttrs,
                                ::FlexFlow::InputAttrs,
                                ::FlexFlow::LayerNormAttrs,
                                ::FlexFlow::LinearAttrs,
                                ::FlexFlow::MultiHeadAttentionAttrs,
                                ::FlexFlow::NoopAttrs,
                                ::FlexFlow::Pool2DAttrs,
                                ::FlexFlow::ReduceAttrs,
                                ::FlexFlow::ReverseAttrs,
                                ::FlexFlow::ReshapeAttrs,
                                ::FlexFlow::SplitAttrs,
                                ::FlexFlow::SoftmaxAttrs,
                                ::FlexFlow::TopKAttrs,
                                ::FlexFlow::TransposeAttrs>>{}(x.raw_variant);
}
} // namespace std
namespace nlohmann {
::FlexFlow::PCGOperatorAttrs
    adl_serializer<::FlexFlow::PCGOperatorAttrs>::from_json(json const &j) {
  std::string key = j.at("type").template get<std::string>();
  if (key == "::FlexFlow::BatchMatmulAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::BatchMatmulAttrs>()};
  } else if (key == "::FlexFlow::BatchNormAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::BatchNormAttrs>()};
  } else if (key == "::FlexFlow::CastAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::CastAttrs>()};
  } else if (key == "::FlexFlow::ConcatAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ConcatAttrs>()};
  } else if (key == "::FlexFlow::Conv2DAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::Conv2DAttrs>()};
  } else if (key == "::FlexFlow::DropoutAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::DropoutAttrs>()};
  } else if (key == "::FlexFlow::ElementBinaryAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ElementBinaryAttrs>()};
  } else if (key == "::FlexFlow::ElementUnaryAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ElementUnaryAttrs>()};
  } else if (key == "::FlexFlow::ElementScalarUnaryAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ElementScalarUnaryAttrs>()};
  } else if (key == "::FlexFlow::EmbeddingAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::EmbeddingAttrs>()};
  } else if (key == "::FlexFlow::FlatAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::FlatAttrs>()};
  } else if (key == "::FlexFlow::GatherAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::GatherAttrs>()};
  } else if (key == "::FlexFlow::InputAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::InputAttrs>()};
  } else if (key == "::FlexFlow::LayerNormAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::LayerNormAttrs>()};
  } else if (key == "::FlexFlow::LinearAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::LinearAttrs>()};
  } else if (key == "::FlexFlow::MultiHeadAttentionAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::MultiHeadAttentionAttrs>()};
  } else if (key == "::FlexFlow::NoopAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::NoopAttrs>()};
  } else if (key == "::FlexFlow::Pool2DAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::Pool2DAttrs>()};
  } else if (key == "::FlexFlow::ReduceAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ReduceAttrs>()};
  } else if (key == "::FlexFlow::ReverseAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ReverseAttrs>()};
  } else if (key == "::FlexFlow::ReshapeAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::ReshapeAttrs>()};
  } else if (key == "::FlexFlow::SplitAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::SplitAttrs>()};
  } else if (key == "::FlexFlow::SoftmaxAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::SoftmaxAttrs>()};
  } else if (key == "::FlexFlow::TopKAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::TopKAttrs>()};
  } else if (key == "::FlexFlow::TransposeAttrs") {
    return ::FlexFlow::PCGOperatorAttrs{
        j.at("value").template get<::FlexFlow::TransposeAttrs>()};
  } else {
    throw std::runtime_error(fmt::format("Unknown type key {}", key));
  }
}
void adl_serializer<::FlexFlow::PCGOperatorAttrs>::to_json(
    json &j, ::FlexFlow::PCGOperatorAttrs const &x) {
  j["__type"] = "PCGOperatorAttrs";
  switch (x.index()) {
    case 0: {
      j["type"] = "::FlexFlow::BatchMatmulAttrs";
      j["value"] = x.get<::FlexFlow::BatchMatmulAttrs>();
      break;
    }
    case 1: {
      j["type"] = "::FlexFlow::BatchNormAttrs";
      j["value"] = x.get<::FlexFlow::BatchNormAttrs>();
      break;
    }
    case 2: {
      j["type"] = "::FlexFlow::CastAttrs";
      j["value"] = x.get<::FlexFlow::CastAttrs>();
      break;
    }
    case 3: {
      j["type"] = "::FlexFlow::ConcatAttrs";
      j["value"] = x.get<::FlexFlow::ConcatAttrs>();
      break;
    }
    case 4: {
      j["type"] = "::FlexFlow::Conv2DAttrs";
      j["value"] = x.get<::FlexFlow::Conv2DAttrs>();
      break;
    }
    case 5: {
      j["type"] = "::FlexFlow::DropoutAttrs";
      j["value"] = x.get<::FlexFlow::DropoutAttrs>();
      break;
    }
    case 6: {
      j["type"] = "::FlexFlow::ElementBinaryAttrs";
      j["value"] = x.get<::FlexFlow::ElementBinaryAttrs>();
      break;
    }
    case 7: {
      j["type"] = "::FlexFlow::ElementUnaryAttrs";
      j["value"] = x.get<::FlexFlow::ElementUnaryAttrs>();
      break;
    }
    case 8: {
      j["type"] = "::FlexFlow::ElementScalarUnaryAttrs";
      j["value"] = x.get<::FlexFlow::ElementScalarUnaryAttrs>();
      break;
    }
    case 9: {
      j["type"] = "::FlexFlow::EmbeddingAttrs";
      j["value"] = x.get<::FlexFlow::EmbeddingAttrs>();
      break;
    }
    case 10: {
      j["type"] = "::FlexFlow::FlatAttrs";
      j["value"] = x.get<::FlexFlow::FlatAttrs>();
      break;
    }
    case 11: {
      j["type"] = "::FlexFlow::GatherAttrs";
      j["value"] = x.get<::FlexFlow::GatherAttrs>();
      break;
    }
    case 12: {
      j["type"] = "::FlexFlow::InputAttrs";
      j["value"] = x.get<::FlexFlow::InputAttrs>();
      break;
    }
    case 13: {
      j["type"] = "::FlexFlow::LayerNormAttrs";
      j["value"] = x.get<::FlexFlow::LayerNormAttrs>();
      break;
    }
    case 14: {
      j["type"] = "::FlexFlow::LinearAttrs";
      j["value"] = x.get<::FlexFlow::LinearAttrs>();
      break;
    }
    case 15: {
      j["type"] = "::FlexFlow::MultiHeadAttentionAttrs";
      j["value"] = x.get<::FlexFlow::MultiHeadAttentionAttrs>();
      break;
    }
    case 16: {
      j["type"] = "::FlexFlow::NoopAttrs";
      j["value"] = x.get<::FlexFlow::NoopAttrs>();
      break;
    }
    case 17: {
      j["type"] = "::FlexFlow::Pool2DAttrs";
      j["value"] = x.get<::FlexFlow::Pool2DAttrs>();
      break;
    }
    case 18: {
      j["type"] = "::FlexFlow::ReduceAttrs";
      j["value"] = x.get<::FlexFlow::ReduceAttrs>();
      break;
    }
    case 19: {
      j["type"] = "::FlexFlow::ReverseAttrs";
      j["value"] = x.get<::FlexFlow::ReverseAttrs>();
      break;
    }
    case 20: {
      j["type"] = "::FlexFlow::ReshapeAttrs";
      j["value"] = x.get<::FlexFlow::ReshapeAttrs>();
      break;
    }
    case 21: {
      j["type"] = "::FlexFlow::SplitAttrs";
      j["value"] = x.get<::FlexFlow::SplitAttrs>();
      break;
    }
    case 22: {
      j["type"] = "::FlexFlow::SoftmaxAttrs";
      j["value"] = x.get<::FlexFlow::SoftmaxAttrs>();
      break;
    }
    case 23: {
      j["type"] = "::FlexFlow::TopKAttrs";
      j["value"] = x.get<::FlexFlow::TopKAttrs>();
      break;
    }
    case 24: {
      j["type"] = "::FlexFlow::TransposeAttrs";
      j["value"] = x.get<::FlexFlow::TransposeAttrs>();
      break;
    }
    default: {
      throw std::runtime_error(
          fmt::format("Unknown index {} for type PCGOperatorAttrs", x.index()));
    }
  }
}
} // namespace nlohmann
namespace FlexFlow {
std::string format_as(::FlexFlow::PCGOperatorAttrs const &x) {
  std::ostringstream oss;
  switch (x.index()) {
    case 0: {
      oss << "<PCGOperatorAttrs ::FlexFlow::BatchMatmulAttrs="
          << x.get<::FlexFlow::BatchMatmulAttrs>() << ">";
      break;
    }
    case 1: {
      oss << "<PCGOperatorAttrs ::FlexFlow::BatchNormAttrs="
          << x.get<::FlexFlow::BatchNormAttrs>() << ">";
      break;
    }
    case 2: {
      oss << "<PCGOperatorAttrs ::FlexFlow::CastAttrs="
          << x.get<::FlexFlow::CastAttrs>() << ">";
      break;
    }
    case 3: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ConcatAttrs="
          << x.get<::FlexFlow::ConcatAttrs>() << ">";
      break;
    }
    case 4: {
      oss << "<PCGOperatorAttrs ::FlexFlow::Conv2DAttrs="
          << x.get<::FlexFlow::Conv2DAttrs>() << ">";
      break;
    }
    case 5: {
      oss << "<PCGOperatorAttrs ::FlexFlow::DropoutAttrs="
          << x.get<::FlexFlow::DropoutAttrs>() << ">";
      break;
    }
    case 6: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ElementBinaryAttrs="
          << x.get<::FlexFlow::ElementBinaryAttrs>() << ">";
      break;
    }
    case 7: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ElementUnaryAttrs="
          << x.get<::FlexFlow::ElementUnaryAttrs>() << ">";
      break;
    }
    case 8: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ElementScalarUnaryAttrs="
          << x.get<::FlexFlow::ElementScalarUnaryAttrs>() << ">";
      break;
    }
    case 9: {
      oss << "<PCGOperatorAttrs ::FlexFlow::EmbeddingAttrs="
          << x.get<::FlexFlow::EmbeddingAttrs>() << ">";
      break;
    }
    case 10: {
      oss << "<PCGOperatorAttrs ::FlexFlow::FlatAttrs="
          << x.get<::FlexFlow::FlatAttrs>() << ">";
      break;
    }
    case 11: {
      oss << "<PCGOperatorAttrs ::FlexFlow::GatherAttrs="
          << x.get<::FlexFlow::GatherAttrs>() << ">";
      break;
    }
    case 12: {
      oss << "<PCGOperatorAttrs ::FlexFlow::InputAttrs="
          << x.get<::FlexFlow::InputAttrs>() << ">";
      break;
    }
    case 13: {
      oss << "<PCGOperatorAttrs ::FlexFlow::LayerNormAttrs="
          << x.get<::FlexFlow::LayerNormAttrs>() << ">";
      break;
    }
    case 14: {
      oss << "<PCGOperatorAttrs ::FlexFlow::LinearAttrs="
          << x.get<::FlexFlow::LinearAttrs>() << ">";
      break;
    }
    case 15: {
      oss << "<PCGOperatorAttrs ::FlexFlow::MultiHeadAttentionAttrs="
          << x.get<::FlexFlow::MultiHeadAttentionAttrs>() << ">";
      break;
    }
    case 16: {
      oss << "<PCGOperatorAttrs ::FlexFlow::NoopAttrs="
          << x.get<::FlexFlow::NoopAttrs>() << ">";
      break;
    }
    case 17: {
      oss << "<PCGOperatorAttrs ::FlexFlow::Pool2DAttrs="
          << x.get<::FlexFlow::Pool2DAttrs>() << ">";
      break;
    }
    case 18: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ReduceAttrs="
          << x.get<::FlexFlow::ReduceAttrs>() << ">";
      break;
    }
    case 19: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ReverseAttrs="
          << x.get<::FlexFlow::ReverseAttrs>() << ">";
      break;
    }
    case 20: {
      oss << "<PCGOperatorAttrs ::FlexFlow::ReshapeAttrs="
          << x.get<::FlexFlow::ReshapeAttrs>() << ">";
      break;
    }
    case 21: {
      oss << "<PCGOperatorAttrs ::FlexFlow::SplitAttrs="
          << x.get<::FlexFlow::SplitAttrs>() << ">";
      break;
    }
    case 22: {
      oss << "<PCGOperatorAttrs ::FlexFlow::SoftmaxAttrs="
          << x.get<::FlexFlow::SoftmaxAttrs>() << ">";
      break;
    }
    case 23: {
      oss << "<PCGOperatorAttrs ::FlexFlow::TopKAttrs="
          << x.get<::FlexFlow::TopKAttrs>() << ">";
      break;
    }
    case 24: {
      oss << "<PCGOperatorAttrs ::FlexFlow::TransposeAttrs="
          << x.get<::FlexFlow::TransposeAttrs>() << ">";
      break;
    }
    default: {
      throw std::runtime_error(
          fmt::format("Unknown index {} for type PCGOperatorAttrs", x.index()));
      break;
    }
  }
  return oss.str();
}
std::ostream &operator<<(std::ostream &s,
                         ::FlexFlow::PCGOperatorAttrs const &x) {
  return s << fmt::to_string(x);
}
} // namespace FlexFlow
